import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt  
import numpy as np
import sys

def sub_projection_basis_isotropic_kernel(nu, n_d, MatReta_d, mDP, nbmDMAP, epsilonDIFFmin, step_epsilonDIFF, 
                                          iterlimit, comp_ref, ind_display_screen, ind_print, ind_plot):
    #------------------------------------------------------------------------------------------------------------------------------------------
    #
    #  Copyright: Christian Soize, Universite Gustave Eiffel, 2 June 2024
    #
    #  Software     : Probabilistic Learning on Manifolds (PLoM) 
    #  Function name: sub_projection_basis_isotropic_kernel.m
    #  Subject      : for ind_basis_type == 2, generating matrix MatRg(n_d,nbmDMAP) of the nbmDMAP projection basis vectors
    #                 solving the eigenvalue problem related to the isotropic kernel
    #
    #  Publications: [1] C. Soize, R. Ghanem, Data-driven probability concentration and sampling on manifold, 
    #                       Journal of Computational Physics,  doi:10.1016/j.jcp.2016.05.044, 321, 242-258 (2016).
    #                [2] C. Soize, R. Ghanem, Probabilistic learning on manifolds, Foundations of Data Science, 
    #                       American  Institute of Mathematical Sciences (AIMS),  doi: 10.3934/fods.2020013, 2(3), 279-307 (2020). .
    #                [3] C. Soize, R. Ghanem, Probabilistic learning on manifolds (PLoM) with partition, International Journal for 
    #                       Numerical Methods in Engineering, doi: 10.1002/nme.6856, 123(1), 268-290 (2022).
    #
    #--- INPUTS 
    #        nu                  : dimension of random vector H = (H_1, ... H_nu)
    #        n_d                 : number of points in the training set for H
    #        MatReta_d(nu,n_d)   : n_d realizations of H 
    #        mDP                 : maximum number of projection-basis vectors that are generated by the isotropic kernel
    #                              with nbmDMAP <= mDP <= n_d
    #        nbmDMAP             : dimension of the projection basis such that nbmDMAP <= mDP   #                            
    #                            --- if ind_basis_type = 2, then the following parameters are required for generating
    #                                   the projection basis by solving the eigenvalue problem related to the isotropic kernel:
    #                                   the smooting paramameter epsilonDIFF   is serached with an iteration algorithm              
    #        epsilonDIFFmin         :   epsilonDIFF is searched in interval [epsilonDIFFmin , +infty[                                    
    #        step_epsilonDIFF       :   step for searching the optimal value epsilonDIFF starting from epsilonDIFFmin
    #        iterlimit              :   maximum number of the iteration algorithm for computing epsilonDIFF                              
    #        comp_ref               :   value in  [ 0.1 , 0.5 [  used for stopping the iteration algorithm.
    #                                   if comp =  Rlambda(nbmDMAP+1)/Rlambda(nbmDMAP) <= comp_ref, then algorithm is stopped
    #                                   The standard value for comp_ref is 0.1 
    #                            --- parameters and variables controling execution
    #        ind_display_screen  : 0, no display, if 1 display
    #        ind_print           : 0, no print, if 1 print
    #        ind_plot            : 0, no plot, if  1 plot
    #        ind_parallel        : 0, no parallel computation, if 1 parallel computation
    #
    #--- OUTPUTS
    #        MatRg(n_d,nbmDMAP)  : matrix of the projection basis
    
    numfig = 0

    #--- Constructing the column matrix contraining the iterlimit values of epsilonDIFF 
    RepsilonDIFF = np.zeros(iterlimit)
    for iter in range(iterlimit):
        RepsilonDIFF[iter] = epsilonDIFFmin + step_epsilonDIFF * iter

    #--- Finding the optimal value epsilonDIFF by solving the iteration algorithm
    Rcomp = np.zeros(iterlimit)                       # Rcomp(iterlimit,1)
    for iter in range(iterlimit):
        # Display
        if ind_display_screen == 1:
            print(f'  iter = {iter + 1}')
        epsilonDIFF_iter = RepsilonDIFF[iter]
       
        # Isotropic kernel, computing MatRKernel_iter(n_d,n_d) 
        co_iter = 1 / (4 * epsilonDIFF_iter)
        MatRtemp1 = np.zeros((n_d,n_d))
        for j in range(n_d):
            MatRtemp2 = np.zeros((nu,n_d))
            for k in range(nu):
                MatRtemp2[k, :] = (MatReta_d[k, :] - MatReta_d[k, j]) ** 2     # MatRtemp2(nu,n_d),MatReta_d(nu,n_d) 
            MatRtemp1[j, :] = np.sum(MatRtemp2, axis=0)                        # MatRtemp1(n_d,n_d),MatRtemp2(nu,n_d)
        MatRKernel_temp = np.exp(-co_iter * MatRtemp1)                         # MatRKernel_temp(n_d,n_d) 
       
        # Removing the negative zeros of the eigenvalues of MatRKernel_temp
        scaling         = np.max(MatRKernel_temp)                              # MatRKernel_temp(n_d,n_d) 
        MatRKernel_iter = MatRKernel_temp + scaling * 1e-12 * np.eye(n_d)      # MatRKernel_iter(n_d,n_d) 
    
        # Computing the transition probability matrix MatRPs       
        MatRPs_iter = np.zeros((n_d,n_d))                                     # MatRPs_iter(n_d,n_d)
        Rd          = np.sum(MatRKernel_iter,axis=1)                          # Rd(n_d),MatRKernel_iter(n_d,n_d) 
        Rdm1s2      = 1.0 / np.sqrt(Rd)                                       # Rdm1s2(n_d)
        for i in range(n_d):
            MatRPs_iter[i, :] = Rdm1s2[i] * MatRKernel_iter[i, :] * Rdm1s2[np.newaxis, :]  # MatRPs_iter(n_d,n_d), Symmetric matrix
        MatRPs_iter = 0.5 * (MatRPs_iter + MatRPs_iter.T)                                  # MatRPs_iter(n_d,n_d), imposing a perfect symmetry

        # Computing the eigenvalues of MatRPs_iter * MatRphi_iter = MatRphi_iter * diag(Rlambda_iter) 
        (Rlambda_iter, MatRphi_iter) = np.linalg.eig(MatRPs_iter)              # Rlambda_iter(n_d,1), MatRphi_iter(n_d,n_d)
        Rlambda_iter = np.real(Rlambda_iter)
        MatRphi_iter = np.real(MatRphi_iter)
        Index        = np.argsort(Rlambda_iter)[::-1]                          # descending order
        Rlambda_iter = Rlambda_iter[Index]                                     # Rlambda_iter(n_d,1)
        MatRphi_iter = MatRphi_iter[:, Index]                                  # MatRphi_iter(n_d,n_d)

        #--- checking the jump in the eigenvalues spectrum with comp = Rlambda_iter(nbmDMAP+1)/Rlambda_iter(nbmDMAP) <= comp_ref 
        comp_iter = Rlambda_iter[nbmDMAP] / Rlambda_iter[nbmDMAP - 1]
        Rcomp[iter] = comp_iter                                                # Rcomp(iterlimit)   
        if comp_iter <= comp_ref:                                              # solution is epsilonDIFF
            epsilonDIFF = epsilonDIFF_iter
            iter_conv = iter
            break
       
        #--- no convergence
        if iter + 1 == iterlimit:  
            # Plot
            if ind_plot == 1:
                plt.figure()
                plt.plot(np.arange(1, iterlimit + 1), Rcomp, 'b-o')
                plt.title('Graph iter $\\mapsto$ Rcomp(iter)', fontsize=16)
                plt.xlabel('iter', fontsize=16) 
                plt.ylabel('Rcomp(iter)', fontsize=16) 
                numfig = numfig + 1
                plt.savefig(f'figure_isotropic_kernel_basis_{numfig}_Rcomp.png') 
                plt.close()
          
            # Display
            print('STOP in sub_projection_basis_isotropic_kernel: iterlimit reached without finding a solution')
          
            # Print
            with open('listing.txt', 'a+') as fidlisting:
                fidlisting.write('\n') 
                fidlisting.write('STOP in sub_projection_basis_isotropic_kernel: iterlimit reached without finding a solution') 

            raise ValueError('STOP in sub_projection_basis_isotropic_kernel: iterlimit reached without finding a solution')
   
    #--- Convergence is reached
    Rlambda   = Rlambda_iter[:mDP]            # Rlambda(mDP),Rlambda_iter(n_d)  
    MatRphi   = MatRphi_iter[:, :mDP]         # MatRphi(n_d,mDP),MatRphi_iter(n_d,n_d)
    MatRg_mDP = np.zeros((n_d,mDP))           # MatRg_mDP(n_d,mDP);                         
    for beta in range(mDP):
        MatRg_mDP[:, beta] = MatRphi[:, beta] * Rdm1s2
        
    #--- Loading the nbmDMAP projection basis vectors (diffusion maps)
    MatRg = MatRg_mDP[:,:nbmDMAP]             # MatRg(n_d,nbmDMAP),MatRg_mDP(n_d,mDP) 
  
    #--- Plot
    if ind_plot == 1:
        if iterlimit - iter_conv >= 1:
            iter_plot = iter_conv + 1
        plt.figure()
        plt.plot(np.arange(1, iter_plot + 1), Rcomp[:iter_plot], 'b-o')
        plt.title('Graph iter $\\mapsto$ Rcomp(iter)', fontsize=16)
        plt.xlabel('iter', fontsize=16)
        plt.ylabel('Rcomp(iter)', fontsize=16)
        numfig = numfig + 1
        plt.savefig(f'figure_isotropic_kernel_basis_{numfig}_Rcomp.png')
        plt.close()

        plt.figure()
        plt.semilogy(np.arange(1, mDP + 1), Rlambda, '-o')
        plt.title('Eigenvalues $\\alpha\\mapsto\\lambda_\\alpha$ of the transition matrix', fontsize=16)
        plt.xlabel('$\\alpha$', fontsize=16)
        plt.ylabel('$\\lambda_\\alpha$', fontsize=16)
        numfig = numfig + 1
        plt.savefig(f'figure_isotropic_kernel_basis_{numfig}_eigenvalueDMAPS.png')
        plt.close()    

    #--- Print
    if ind_print == 1:
        with open('listing.txt', 'a+') as fidlisting:
            fidlisting.write('\n') 
            fidlisting.write(' ----- sub_projection_basis_isotropic_kernel: construction of the DMAPS basis for the isotropic kernel \n ')                        
            fidlisting.write('\n') 
            fidlisting.write('\n') 
            fidlisting.write(f' n_d              = {n_d:7d} \n') 
            fidlisting.write(f' mDP              = {mDP:7d} \n') 
            fidlisting.write(f' nbmDMAP          = {nbmDMAP:7d} \n') 
            fidlisting.write('\n')
            fidlisting.write(f' epsilonDIFFmin   = {epsilonDIFFmin:14.7e} \n') 
            fidlisting.write(f' step_epsilonDIFF = {step_epsilonDIFF:14.7e} \n') 
            fidlisting.write(f' epsilonDIFF      = {epsilonDIFF:14.7e} \n') 
            fidlisting.write('\n') 
            fidlisting.write(' eigenvalues of the transition matrix \n ')                        
            fidlisting.write('\n') 
            Rnum = np.arange(1, mDP + 1)
            MatRprint = np.column_stack((Rnum, Rlambda))                                        
            for row in MatRprint:
                fidlisting.write(f' {int(row[0]):5d} {row[1]:18.11e} \n')

    return MatRg
